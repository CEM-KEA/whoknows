name: deploy

on:
  push:
    branches:
      - main

jobs:
  get_version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.set_output.outputs.version }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history and tags

      - name: Verify Git Tags
        run: git tag

      - name: Get Current Tag
        id: get_tag
        run: |
          VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "DEBUG: Got version: $VERSION"

      - name: Increment Minor Version Tag
        id: set_output
        run: |
          # Extract the version numbers
          CURRENT_TAG=$VERSION
          MAJOR=$(echo $CURRENT_TAG | cut -d'.' -f1 | sed 's/v//')
          MINOR=$(echo $CURRENT_TAG | cut -d'.' -f2)

          # Increment the minor version and check if the tag exists
          NEW_MINOR=$((MINOR+1))
          NEW_TAG="v$MAJOR.$NEW_MINOR"
          while git rev-parse "$NEW_TAG" >/dev/null 2>&1; do
            NEW_MINOR=$((NEW_MINOR+1))
            NEW_TAG="v$MAJOR.$NEW_MINOR"
          done

          # Output the new tag
          echo "New tag will be: $NEW_TAG"
          echo "version=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "DEBUG: New version tag: $NEW_TAG"

  build_and_push:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.set_build_image_tag.outputs.image_tag }}
    needs: get_version
    env:
      IMAGE_TAG: ${{ needs.get_version.outputs.version }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Log into GitHub Container Registry
        run: echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Set Repository Name to Lowercase
        id: set_repo_name
        run: |
          REPO_NAME=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_name=$REPO_NAME" >> $GITHUB_ENV
      
      - name: Build and Push Backend Image
        run: |
          docker build -t ghcr.io/${{ env.repo_name }}/backend:${{env.IMAGE_TAG}} ./backend
          docker push ghcr.io/${{ env.repo_name }}/backend:${{env.IMAGE_TAG}}
      
      - name: Build and Push Frontend Image
        run: |
          docker build -t ghcr.io/${{ env.repo_name }}/frontend:${{env.IMAGE_TAG}} ./frontend
          docker push ghcr.io/${{ env.repo_name }}/frontend:${{env.IMAGE_TAG}}
      

      - name: Set Build Image Tag
        id: set_build_image_tag
        run: | 
          echo "image_tag=${{ env.IMAGE_TAG }}" >> $GITHUB_OUTPUT
          echo "DEBUG: Image tag: ${{ env.IMAGE_TAG }}"

  deploy_and_release:
    runs-on: ubuntu-latest
    needs: build_and_push
    env:
      IMAGE_TAG: ${{ needs.build_and_push.outputs.image_tag }}

    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Deploy to Azure VM
        run: |
          echo "Deploying with IMAGE_TAG: ${{ env.IMAGE_TAG }}"

          # SSH into the Azure VM and deploy
          ssh -o StrictHostKeyChecking=no ${{ secrets.AZURE_VM_USER }}@${{ secrets.AZURE_VM_IP }} << EOF
            cd /home/azureuser/whoknows || exit

            # Pull the latest code
            git pull origin main

            # Generate the .env file
            echo "API_SERVER_PORT=${{ secrets.API_SERVER_PORT }}" > .env
            echo "API_DATABASE_FILE_PATH=./app/internal/database/whoknows.db" >> .env
            echo "API_DATABASE_MIGRATE=${{ secrets.API_DATABASE_MIGRATE }}" >> .env
            echo "API_DATABASE_SEED=${{ secrets.API_DATABASE_SEED }}" >> .env
            echo "API_DATABASE_SEED_FILE_PATH=./app/internal/database/pages.json" >> .env
            echo "API_JWT_SECRET=${{ secrets.API_JWT_SECRET }}" >> .env
            echo "API_JWT_EXPIRATION=${{ secrets.API_JWT_EXPIRATION }}" >> .env
            echo "API_APP_ENVIRONMENT=${{ secrets.API_APP_ENVIRONMENT }}" >> .env
            echo "API_PAGINATION_LIMIT=${{ secrets.API_PAGINATION_LIMIT }}" >> .env
            echo "API_PAGINATION_OFFSET=${{ secrets.API_PAGINATION_OFFSET }}" >> .env
            echo "API_LOG_LEVEL=${{ secrets.API_LOG_LEVEL }}" >> .env
            echo "API_LOG_FORMAT=${{ secrets.API_LOG_FORMAT }}" >> .env
            echo "VITE_API_URL=${{ secrets.VITE_API_URL }}" >> .env
            echo "API_WEATHER_API_KEY=${{ secrets.API_WEATHER_API_KEY }}" >> .env
            echo "IMAGE_TAG=${{ env.IMAGE_TAG }}" >> .env

            # Build and start Docker services
            echo "Building and starting Docker services..."
            docker compose down
            docker compose up --build -d
          EOF

      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history and tags in order to push a new tag and generate a release

      - name: Create New Tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure git user for tagging
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          # Create and push the new tag
          git tag ${{ env.IMAGE_TAG }}
          git push origin ${{ env.IMAGE_TAG }}

      - name: Create Release with GitHub CLI
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          echo "Creating release for tag: ${{ env.IMAGE_TAG }}"
          gh release create ${{ env.IMAGE_TAG }} \
          --title "Release ${{ env.IMAGE_TAG }}" \
          --notes "This is an automatically generated release with all the latest changes." \
          --generate-notes
