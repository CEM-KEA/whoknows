name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  get_version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.set_output.outputs.version }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history and tags

      - name: Verify Git Tags
        run: git tag

      - name: Get Current Tag
        id: get_tag
        run: |
          VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "DEBUG: Got version: $VERSION"

      - name: Increment Minor Version Tag
        id: set_output
        run: |
          # Extract the version numbers
          CURRENT_TAG=${{ env.VERSION }}
          MAJOR=$(echo $CURRENT_TAG | cut -d'.' -f1 | sed 's/v//')
          MINOR=$(echo $CURRENT_TAG | cut -d'.' -f2)

          # Increment the minor version
          NEW_MINOR=$((MINOR+1))
          NEW_TAG="v$MAJOR.$NEW_MINOR"

          # Output the new tag
          echo "New tag will be: $NEW_TAG"
          echo "version=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "DEBUG: New version tag: $NEW_TAG"

  build_and_test:
    runs-on: ubuntu-latest
    needs: get_version
    outputs:
      image_tag: ${{ steps.set_image_tag.outputs.image_tag }}
    env:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      SONAR_ORGANIZATION: ${{ secrets.SONAR_ORGANIZATION }}
      SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
      IMAGE_TAG: ${{ needs.get_version.outputs.version }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.23"

      - name: SonarQube Scan Monorepo
        uses: sonarsource/sonarcloud-github-action@v3
        with:
          args: |
            -Dsonar.projectKey=${{ env.SONAR_PROJECT_KEY }}
            -Dsonar.organization=${{ env.SONAR_ORGANIZATION }}
            -Dsonar.token=${{ env.SONAR_TOKEN }}
            -Dsonar.host.url=${{ env.SONAR_HOST_URL }}
            -Dsonar.sources=./backend,./frontend,./legacy,./compose.yml
            -Dsonar.exclusions=**/node_modules/**,**/test/**,**/legacy/**
            -Dsonar.tests=./backend,./frontend
            -Dsonar.test.inclusions=**/*.spec.ts,**/*.spec.ts,**/*_test.go
            -Dsonar.go.coverage.reportPaths=**/coverage.out
            -Dsonar.go.tests.reportPaths=**/report.json

      - name: Run Backend Tests
        run: |
          cd backend
          go test -coverprofile=coverage.out -covermode=count -json > report.json ./...

      # - name: Generate .env file for Docker Compose
      #   run: |
      #     echo "API_SERVER_PORT=${{ secrets.API_SERVER_PORT }}" > .env
      #     echo "API_DATABASE_FILE_PATH=./app/internal/database/whoknows.db" >> .env
      #     echo "API_DATABASE_MIGRATE=${{ secrets.API_DATABASE_MIGRATE }}" >> .env
      #     echo "API_DATABASE_SEED=${{ secrets.API_DATABASE_SEED }}" >> .env
      #     echo "API_DATABASE_SEED_FILE_PATH=./app/internal/database/pages.json" >> .env
      #     echo "API_JWT_SECRET=${{ secrets.API_JWT_SECRET }}" >> .env
      #     echo "API_JWT_EXPIRATION=${{ secrets.API_JWT_EXPIRATION }}" >> .env
      #     echo "API_APP_ENVIRONMENT=${{ secrets.API_APP_ENVIRONMENT }}" >> .env
      #     echo "API_PAGINATION_LIMIT=${{ secrets.API_PAGINATION_LIMIT }}" >> .env
      #     echo "API_PAGINATION_OFFSET=${{ secrets.API_PAGINATION_OFFSET }}" >> .env
      #     echo "API_LOG_LEVEL=${{ secrets.API_LOG_LEVEL }}" >> .env
      #     echo "API_LOG_FORMAT=${{ secrets.API_LOG_FORMAT }}" >> .env
      #     echo "VITE_API_URL=${{ secrets.VITE_API_URL }}" >> .env
      #     echo "API_WEATHER_API_KEY=${{ secrets.API_WEATHER_API_KEY }}" >> .env
      #     echo "IMAGE_TAG=${{ env.IMAGE_TAG }}" >> .env

      # - name: Create External Volume
      #   run: |
      #     if ! docker volume ls --format '{{.Name}}' | grep -q "^sqlite_data$"; then
      #       echo "Creating external volume 'sqlite_data'..."
      #       docker volume create sqlite_data
      #     else
      #       echo "Volume 'sqlite_data' already exists."
      #     fi

      # - name: Start Docker Compose (Backend + Frontend)
      #   run: |
      #     docker compose --env-file .env up -d  # Start both backend and frontend services

      #    # - name: Wait for Frontend to be Ready
      #   run: |
      #     MAX_RETRIES=30  # Max number of retries (e.g., 30 retries = 5 minutes with 10s wait)
      #     RETRY_INTERVAL=10  # Interval between retries in seconds
      #     retries=0

      #     until curl -s http://localhost:80 > /dev/null; do
      #       retries=$((retries+1))
      #       if [ "$retries" -ge "$MAX_RETRIES" ]; then
      #         echo "Frontend did not become ready within the timeout. Exiting."
      #         exit 1
      #       fi
      #       echo "Waiting for frontend (nginx) to be ready... (Attempt: $retries/$MAX_RETRIES)"
      #       sleep $RETRY_INTERVAL
      #     done

      #     echo "Frontend is ready!"

      # - name: Install Dependencies for Playwright
      #   run: |
      #     npx playwright install-deps

      # - name: Install Playwright
      #   run: |
      #     cd frontend
      #     npm install @playwright/test
      #     npx playwright install

      # - name: Run End-to-End Tests
      #   env:
      #     TEST_FRONTEND_URL: http://localhost
      #     TEST_LOGIN_USERNAME: ${{ secrets.TEST_LOGIN_USERNAME }}
      #     TEST_LOGIN_PASSWORD: ${{ secrets.TEST_LOGIN_PASSWORD }}
      #   run: |
      #     cd frontend
      #     npx playwright test

      - name: Set Output Image Tag
        id: set_image_tag
        run: echo "image_tag=${{ env.IMAGE_TAG }}" >> $GITHUB_OUTPUT

      - name: Print Image Tag
        run: "echo 'Built with IMAGE_TAG: ${{ env.IMAGE_TAG }}'"

  deploy:
    runs-on: ubuntu-latest
    needs: build_and_test
    outputs:
      image_tag: ${{ steps.set_deploy_image_tag.outputs.image_tag }}
    env:
      IMAGE_TAG: ${{ needs.build_and_test.outputs.image_tag }}

    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Deploy to Azure VM
        run: |
          echo "Deploying with IMAGE_TAG: ${{ env.IMAGE_TAG }}"

          # SSH into the Azure VM and deploy
          ssh -o StrictHostKeyChecking=no ${{ secrets.AZURE_VM_USER }}@${{ secrets.AZURE_VM_IP }} << EOF
            cd /home/azureuser/whoknows || exit

            # Pull the latest code
            git pull origin main

            # Generate the .env file
            echo "API_SERVER_PORT=${{ secrets.API_SERVER_PORT }}" > .env
            echo "API_DATABASE_FILE_PATH=./app/internal/database/whoknows.db" >> .env
            echo "API_DATABASE_MIGRATE=${{ secrets.API_DATABASE_MIGRATE }}" >> .env
            echo "API_DATABASE_SEED=${{ secrets.API_DATABASE_SEED }}" >> .env
            echo "API_DATABASE_SEED_FILE_PATH=./app/internal/database/pages.json" >> .env
            echo "API_JWT_SECRET=${{ secrets.API_JWT_SECRET }}" >> .env
            echo "API_JWT_EXPIRATION=${{ secrets.API_JWT_EXPIRATION }}" >> .env
            echo "API_APP_ENVIRONMENT=${{ secrets.API_APP_ENVIRONMENT }}" >> .env
            echo "API_PAGINATION_LIMIT=${{ secrets.API_PAGINATION_LIMIT }}" >> .env
            echo "API_PAGINATION_OFFSET=${{ secrets.API_PAGINATION_OFFSET }}" >> .env
            echo "API_LOG_LEVEL=${{ secrets.API_LOG_LEVEL }}" >> .env
            echo "API_LOG_FORMAT=${{ secrets.API_LOG_FORMAT }}" >> .env
            echo "VITE_API_URL=${{ secrets.VITE_API_URL }}" >> .env
            echo "API_WEATHER_API_KEY=${{ secrets.API_WEATHER_API_KEY }}" >> .env
            echo "IMAGE_TAG=${{ env.IMAGE_TAG }}" >> .env

            # Build and start Docker services
            echo "Building and starting Docker services..."
            docker compose down
            docker compose up --build -d
          EOF

      - name: Set Deploy Image Tag
        id: set_deploy_image_tag
        run: echo "image_tag=${{ env.IMAGE_TAG }}" >> $GITHUB_OUTPUT

  create_release:
    runs-on: ubuntu-latest
    needs: deploy
    env:
      IMAGE_TAG: ${{ needs.deploy.outputs.image_tag }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history and tags

      - name: Create New Tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure git user for tagging
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          # Create and push the new tag
          git tag ${{ env.IMAGE_TAG }}
          git push origin ${{ env.IMAGE_TAG }}

      - name: Create Release with GitHub CLI
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Creating release for tag: ${{ env.IMAGE_TAG }}"
          gh release create ${{ env.IMAGE_TAG }} \
          --title "Release ${{ env.IMAGE_TAG }}" \
          --notes "This is an automatically generated release with all the latest changes." \
          --generate-notes
