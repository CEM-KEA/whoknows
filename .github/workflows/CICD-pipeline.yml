name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  get_version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.set_output.outputs.version }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Get Current Tag
        id: get_tag
        run: |
          VERSION=$(git describe --tags --abbrev=0 || echo "v0.0.0")
          echo "version=$VERSION" >> $GITHUB_ENV

      - name: Set Output
        id: set_output
        run: |
          echo "::set-output name=version::${VERSION}" # Ensure correct set-output usage

  build_and_test:
    runs-on: ubuntu-latest
    needs: get_version
    outputs:
      image_tag: ${{ steps.set_image_tag.outputs.image_tag }} # Define the output for the job
    env:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      SONAR_ORGANIZATION: ${{ secrets.SONAR_ORGANIZATION }}
      SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
      IMAGE_TAG: ${{ needs.get_version.outputs.version }} # Use the version from the previous job

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.23"

      - name: SonarQube Scan Monorepo
        uses: sonarsource/sonarcloud-github-action@v3
        with:
          args: >
            -Dsonar.projectKey=$SONAR_PROJECT_KEY
            -Dsonar.organization=$SONAR_ORGANIZATION
            -Dsonar.host.url=$SONAR_HOST_URL
            -Dsonar.login=$SONAR_TOKEN
            -Dsonar.sources=./backend,./frontend,./legacy,./compose.yml
            -Dsonar.exclusions=**/node_modules/**,**/test/**,**/legacy/**  # Exclude test files and legacy code

      # Run backend tests
      - name: Run Backend Tests
        run: |
          cd backend
          go test ./...

      # Build backend and frontend Docker images using the tag from get_version
      - name: Build Backend Docker Image
        run: |
          cd backend
          docker build -t whoknows-backend:${{ env.IMAGE_TAG }} .
  
      - name: Build Frontend Docker Image
        run: |
          cd frontend
          docker build -t whoknows-frontend:${{ env.IMAGE_TAG }} .

      # Set up Playwright for end-to-end tests
      - name: Install Playwright
        run: |
          cd frontend
          npm install @playwright/test
          npx playwright install

      # Run end-to-end tests
      - name: Run End-to-End Tests
        run: |
          cd frontend
          npx playwright test

      # Set output for image_tag
      - name: Set Output Image Tag
        id: set_image_tag
        run: |
          echo "::set-output name=image_tag::${{ env.IMAGE_TAG }}" # Set image_tag as output

  deploy:
    runs-on: ubuntu-latest
    needs: build_and_test
    outputs:
      image_tag: ${{ steps.set_deploy_image_tag.outputs.image_tag }} # Set output for the deploy job
    env:
      IMAGE_TAG: ${{ needs.build_and_test.outputs.image_tag }} # Access the image_tag output from build_and_test

    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Deploy to Azure VM
        run: |
          echo "Deploying with IMAGE_TAG: ${{ env.IMAGE_TAG }}"

          # SSH into the Azure VM and deploy
          ssh -o StrictHostKeyChecking=no ${{ secrets.AZURE_VM_USER }}@${{ secrets.AZURE_VM_IP }} << EOF
            cd /home/azureuser/whoknows || exit

            # Generate the .env file
            echo "API_SERVER_PORT=${{ secrets.API_SERVER_PORT }}" > .env
            echo "API_DATABASE_FILE_PATH=./app/internal/database/whoknows.db" >> .env
            echo "API_DATABASE_MIGRATE=${{ secrets.API_DATABASE_MIGRATE }}" >> .env
            echo "API_DATABASE_SEED=${{ secrets.API_DATABASE_SEED }}" >> .env
            echo "API_DATABASE_SEED_FILE_PATH=./app/internal/database/pages.json" >> .env
            echo "API_JWT_SECRET=${{ secrets.API_JWT_SECRET }}" >> .env
            echo "API_JWT_EXPIRATION=${{ secrets.API_JWT_EXPIRATION }}" >> .env
            echo "API_APP_ENVIRONMENT=${{ secrets.API_APP_ENVIRONMENT }}" >> .env
            echo "API_PAGINATION_LIMIT=${{ secrets.API_PAGINATION_LIMIT }}" >> .env
            echo "API_PAGINATION_OFFSET=${{ secrets.API_PAGINATION_OFFSET }}" >> .env
            echo "API_LOG_LEVEL=${{ secrets.API_LOG_LEVEL }}" >> .env
            echo "API_LOG_FORMAT=${{ secrets.API_LOG_FORMAT }}" >> .env
            echo "VITE_API_URL=${{ secrets.VITE_API_URL }}" >> .env
            echo "API_WEATHER_API_KEY=${{ secrets.API_WEATHER_API_KEY }}" >> .env
            echo "IMAGE_TAG=${{ env.IMAGE_TAG }}" >> .env

            # Load local Docker images
            echo "Loading Docker images..."
            docker save whoknows-backend:${{ env.IMAGE_TAG }} | docker load
            docker save whoknows-frontend:${{ env.IMAGE_TAG }} | docker load

            # Update Docker images and restart services
            echo "Pulling and starting Docker services..."
            docker compose down
            docker compose up -d
          EOF

      # Set output for image_tag after deployment
      - name: Set Deploy Image Tag
        id: set_deploy_image_tag
        run: |
          echo "::set-output name=image_tag::${{ env.IMAGE_TAG }}"

  create_release:
    runs-on: ubuntu-latest
    needs: deploy # This job runs after deploy
    steps:
      - name: Create Release with GitHub CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Set the GH_TOKEN environment variable for authentication
        run: |
          echo "Creating release for tag: ${{ needs.deploy.outputs.image_tag }}"

          # Create a new release with autogenerated release notes
          gh release create ${{ needs.deploy.outputs.image_tag }} \
          --title "Release ${{ needs.deploy.outputs.image_tag }}" \
          --notes "This is an automatically generated release with all the latest changes." \
          --generate-notes

      - name: Upload Assets to Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Set the GH_TOKEN environment variable for authentication
        run: |
          # Debugging step: Verify the tag name
          echo "Uploading assets to release: ${{ needs.deploy.outputs.image_tag }}"

          # Upload assets to the release, if any
          gh release upload ${{ needs.deploy.outputs.image_tag }} path/to/your/asset.zip
